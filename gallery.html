<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <!--Favicon-->
    <link rel="shortcut icon" href="images/favicon.ico" />
    <title>Gallery</title>
    <!-- Babylon.js -->

    <script src="js/babylon.js"></script>
    <script src="js/Oimo.js"></script>
    <script src="js/leap.js"></script>
    <script src="js/leap-plugins-0.1.11.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/annyang/2.4.0/annyang.min.js"></script>

    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

</head>
<body>

<canvas id="renderCanvas"></canvas>

<script type="text/javascript">

	
    var leapX = 0;
    var leapY = 0;
	var leapZ = 0;	
	
    // Scene Creation
    var canvas = document.getElementById("renderCanvas");

    var engine = new BABYLON.Engine(canvas, true);
    var scene = new BABYLON.Scene(engine);

    //Physics
<<<<<<< HEAD
	scene.enablePhysics(new BABYLON.Vector3(0, -200, 0), new BABYLON.OimoJSPlugin());
=======
	//scene.enablePhysics(new BABYLON.Vector3(0, -200, 0), new BABYLON.OimoJSPlugin());
>>>>>>> origin/master
	
    var camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2, canvas.width / 2, BABYLON.Vector3.Zero(), scene);
    scene.activeCamera = camera;
    camera.attachControl(canvas, true);
    camera.applyGravity = true;

	var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 0, -1), scene);

	light.intensity = 1;
	/*
	var imgCanvas = document.createElement('imgCanvas');
	var context = imgCanvas.getContext('2d');
	var img = document.getElementById('myimg');
	context.drawImage(img, 0, 0 );
	var myData = context.getImageData(0, 0, img.width, img.height); */
	
    // CREATE GALLERY
    var index = 1;
    var gallery = new Array();
    for (var x = 0; x <= 250; x += 200){
        for (var y = 0; y <= 250; y += 200){
			

    		//Creation of a repeated textured material
   			var materialPlane = new BABYLON.StandardMaterial("texturePlane"+index, scene);
   			materialPlane.diffuseTexture = new BABYLON.Texture("gallery/img" + index + ".jpg", scene);
			materialPlane.specularColor = new BABYLON.Color3(0, 0, 0);
  			materialPlane.backFaceCulling = false;//Allways show the front and the back of an element

    		//Creation of a plane
    		var plane = BABYLON.Mesh.CreatePlane("image"+index, 120, scene);
    		plane.material = materialPlane;
    		
    		plane.position.y = y ;
            plane.position.x = x ;
            plane.position.z = 0;

            plane.isPickable = true;

            gallery.push(plane);
            
            index++;

        }
    }
    

    var bild = scene.getMeshByID("image1").material.diffuseTexture;
 	


    var leapBox =  BABYLON.Mesh.CreateBox("leapBox",10,scene);
    var leapMaterial = new BABYLON.StandardMaterial("leapMaterial", scene);
    leapMaterial.diffuseColor = new BABYLON.Color3(1.0, 0.2, 0.7);

    leapBox.material = leapMaterial;

    // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
    var ground = BABYLON.Mesh.CreateGround("ground", camera.radius, camera.radius, 2, scene);

    ground.position.y -= 300;
    ground.setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 0 });
    // --------------- annyang Functions --------------------------

    
	var addBox = function () {
        // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
        var box = BABYLON.Mesh.CreateBox("box",  3, scene);

        box.position.y = 15 - Math.floor((Math.random() * 30) + 1);
        box.position.x = 15 - Math.floor((Math.random() * 30) + 1);
        box.position.z = Math.floor((Math.random() * 10) + 1);
        box.setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 4 });
        box.isPickable = true;


    };

    var addSphere = function () {
        // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
        var sphere = BABYLON.Mesh.CreateSphere("sphere",  3, 3, scene);
        sphere.position.y = 15 - Math.floor((Math.random() * 30) + 1);
        sphere.position.x = 15 - Math.floor((Math.random() * 30) + 1);
        sphere.position.z = Math.floor((Math.random() * 10) + 1);
        sphere.setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 4 });
        sphere.isPickable = true;


    };

    var randomPosBoxes = function () {
        // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
        for (var x = 0; x <boxes.length; x++){
            boxes[x].position.z = Math.floor((Math.random() * 10) + 1);
        }
    };

    var physics = function () {
        scene.enablePhysics(new BABYLON.Vector3(0, -10, 0), new BABYLON.OimoJSPlugin());
    };


    // Resize
    window.addEventListener("resize", function () {
        engine.resize();

    });

	// -------- ANNYANG ------------
	if (annyang) {

        annyang.setLanguage("de-DE");
        // Let's define a command.
        var commands = {

            'Kugel' : addSphere,
            'Box' : addBox,
            'Physik' : physics,
            'Zufall' : randomPosBoxes
        };
        annyang.debug(true);
        // Add our commands to annyang
        annyang.addCommands(commands);


        // Start listening.
        annyang.start(true, true);
    }
    
    // ------------------------------

    var predicate = function(mesh) {

        return mesh.isPickable && mesh.isEnabled()

    }

    // Show some Debug Axis
    var showAxis = function(size) {
        var makeTextPlane = function(text, color, size) {
            var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
            dynamicTexture.hasAlpha = true;
            dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color , "transparent", true);
            var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
            plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
            plane.material.backFaceCulling = false;
            plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
            plane.material.diffuseTexture = dynamicTexture;
            return plane;
        };

        var axisX = BABYLON.Mesh.CreateLines("axisX", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
            new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
        ], scene);
        axisX.color = new BABYLON.Color3(1, 0, 0);
        var xChar = makeTextPlane("X", "red", size / 10);
        xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);
        var axisY = BABYLON.Mesh.CreateLines("axisY", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3( -0.05 * size, size * 0.95, 0),
            new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3( 0.05 * size, size * 0.95, 0)
        ], scene);
        axisY.color = new BABYLON.Color3(0, 1, 0);
        var yChar = makeTextPlane("Y", "green", size / 10);
        yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
        var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3( 0 , -0.05 * size, size * 0.95),
            new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3( 0, 0.05 * size, size * 0.95)
        ], scene);
        axisZ.color = new BABYLON.Color3(0, 0, 1);
        var zChar = makeTextPlane("Z", "blue", size / 10);
        zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
    };

    showAxis(200)

    // Show Debug Ray for Leap Position
    var debugRay = BABYLON.Mesh.CreateLines("debugRay", [
        new BABYLON.Vector3(camera.position.x, camera.position.y, camera.position.z),
        new BABYLON.Vector3(0, 0, -300),

    ], scene);
    								console.log(gallery.length);


	var displayArea = canvas.getContext("2d");
	
    // Render Loop + Leap Loop
    engine.runRenderLoop(function () {
            var controller = Leap.loop({enableGestures:true}, function(frame) {
            
            var radius = camera.radius;
			
			var previousFrame = controller.frame[1];
			
			var appWidth = radius * 2;
			var appHeight = canvas.height;

                if(frame.hands.length > 0)
                {
					
                    var hand = frame.hands[0];
                    var position = hand.palmPosition;
                    var velocity = hand.palmVelocity;
                    var direction = hand.direction;
                    
					// ---------- LEAP COORDINATE MAPPING IN CAMERA COORDINATE ----------------
					
					canvas.width = canvas.width; //clear
					var interactionBox = frame.interactionBox;
					
					var normalizedPosition = interactionBox.normalizePoint(position, true);
  
 					var canvasX = radius*2 * normalizedPosition[0] ;
      				var canvasY = radius*2 * (1 - normalizedPosition[1]);
      				var canvasZ = radius * 2 * normalizedPosition[2]

					leapX = (radius) - canvasX;
					leapY = (radius) - canvasY;
					leapZ = (radius) - canvasZ;
					
					leapBox.position.x = leapX;
					leapBox.position.y = leapY;
					
<<<<<<< HEAD
				//	console.log("x :" + leapX + " - y :" + leapY);
=======
				    //	console.log("x :" + leapX + " - y :" + leapY);
>>>>>>> origin/master

					// ------- RAY COLLOSION -------------
                    debugRay.position.x = leapX;
                    debugRay.position.y = leapY;

                    var origin = new BABYLON.Vector3(0,0,100)
                    var pos = new BABYLON.Vector3(leapX,leapY,0);

                    var dir = pos.subtract(origin).normalize();

                    var ray = new BABYLON.Ray(debugRay.position, new BABYLON.Vector3(0, 0, 1),300);

                    var mesh = scene.pickWithRay(ray);
                    
                    //----------- 5 Finger = Zoom --------------------
                    if(hand.fingers.length == 5 && hand.pinchStrength <= 0.2 && hand.type == "right" ) {
                    	var velZoom = velocity[1]/canvas.width/2;
                    	if(velocity[1] < 0){
                    		if(camera.radius >=1 ){
                    			camera.radius += velZoom;
                    		} else { camera.radius =1;}
                    	} else {
                    		camera.radius += velZoom;
                    	}
                    } 

                    if (mesh.pickedMesh != null){
                        // Highlight selected Mesh
                        mesh.pickedMesh.outlineWidth = 0.3;
                        mesh.pickedMesh.renderOutline = true;

                        // Hand closed >> Move selected mesh
                        if(hand.grabStrength >= 0.6){
                        	mesh.pickedMesh.position.x = leapX;
                            mesh.pickedMesh.position.y = leapY;
                        //    mesh.pickedMesh.position.z = -1 * leapZ / 2;
                        	mesh.pickedMesh.updatePhysicsBodyPosition();
                        	
                        	// ----------- LEFT HAND SCALE IMAGE ---------------
                        	if(frame.hands[1]){
                        	
                        		var handNormPosition = interactionBox.normalizePoint(frame.hands[1].palmPosition, true);
  
                        		var velHand = frame.hands[1].palmVelocity;
                        		if(velHand[1] < 0){
                    				mesh.pickedMesh.scaling.x = handNormPosition[1]*2;
                    				mesh.pickedMesh.scaling.y = handNormPosition[1]*2;
                    			} else {
                    				mesh.pickedMesh.scaling.x = handNormPosition[1]*2;
                    				mesh.pickedMesh.scaling.y = handNormPosition[1]*2;                    			}
                    			}
                        }
                    }
                    
                    if(frame.valid && frame.gestures.length > 0){
                    frame.gestures.forEach(function(gesture){
                        switch (gesture.type){
                            case "circle":
								var state = gesture.state;
								if(state == "start"){
								
                               		for(var i = 0; gallery.length > i; i++){
    								//Creation of a plane
    								gallery[i].material.diffuseTexture  = new BABYLON.Texture("gallery/img" + index + ".jpg", scene);
    								index++;
    								if(index > 8){index = 1;}
                             		}
                             	}
                              //  console.log("Circle Gesture");
                                break;
                            case "keyTap":
                            //    console.log("key tap Gesture");
							
                                break;
                            case "screenTap":
                           //     var position = gesture.position;
                           //     console.log("screen tap Gesture" + position);
                                break;
                            case "swipe":
                           //     console.log("Swipe Gesture");

                                break;
                    }
                    });
                }
                }


        }).use('screenPosition', {scale: 1});
        
       
        
        scene.render();

    });

</script>
</body>
</html>