<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <!--Favicon-->
    <link rel="shortcut icon" href="images/favicon.ico"/>
    <title>Babylon meets Leap Motion</title>
    <!-- Babylon.js -->

    <script src="js/babylon.js"></script>
    <script src="js/Oimo.js"></script>
    <script src="js/leap.js"></script>
    <script src="js/leap-plugins-0.1.11.js"></script>
    <script src="js/hand.js"></script>
    <script src="js/babylon.waterMaterial.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/annyang/2.4.0/annyang.min.js"></script>

    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>

</head>
<body>


<canvas id="renderCanvas"></canvas>
<script type="text/javascript">

    // Leap Coordinates
    var leapX = 0;
    var leapY = 0;
    var leapZ = 0;

    // Objects that can be created
    var stoneMove = false;
    var stoneIndex = 0;
    var stoneMesh = 0;
    var stones = new Array();

    var tree = false;

    // Scene Creation
    var canvas = document.getElementById("renderCanvas");

    var engine = new BABYLON.Engine(canvas, true);
    var scene = new BABYLON.Scene(engine);

    //Physics
    scene.enablePhysics(new BABYLON.Vector3(0, -200, 0), new BABYLON.OimoJSPlugin());

    var camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 3, canvas.width, BABYLON.Vector3.Zero(), scene);
    scene.activeCamera = camera;
    camera.attachControl(canvas, true);
    camera.applyGravity = true;

    var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

    light.intensity = 0.8;

    // Skybox
    var skybox = BABYLON.Mesh.CreateBox("skyBox", canvas.width*4, scene);
    var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/morning", scene);
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    skybox.material = skyboxMaterial;


    // Debug Box
    var leapBox = BABYLON.Mesh.CreateBox("leapBox", 30, scene);
    var leapMaterial = new BABYLON.StandardMaterial("leapMaterial", scene);
    leapMaterial.diffuseColor = new BABYLON.Color3(1.0, 0.2, 0.7);
    leapBox.material = leapMaterial;

    // Ground Terrain
    var ground = BABYLON.Mesh.CreateGround("ground", camera.radius, camera.radius, 2, scene);
    var groundMaterial = new BABYLON.StandardMaterial("groundMaterial", scene);
    groundMaterial.diffuseTexture = new BABYLON.Texture("texturen/sand.jpg", scene);
    groundMaterial.diffuseTexture.uScale = 4;
    groundMaterial.diffuseTexture.vScale = 4;
    ground.material = groundMaterial;
    ground.isPickable = true;
    ground.position.y -= 50;

    // Water material
    var waterMaterial = new BABYLON.WaterMaterial("waterMaterial", scene, new BABYLON.Vector2(32, 32));
    waterMaterial.bumpTexture = new BABYLON.Texture("Water/bump.png", scene);
    waterMaterial.windForce = -10;
    waterMaterial.waveHeight = 2.5;
    waterMaterial.bumpHeight = 1.1;
    waterMaterial.waveLength = 0.1;
    waterMaterial.waveSpeed = 50.0;
    waterMaterial.colorBlendFactor = 0;
    waterMaterial.windDirection = new BABYLON.Vector2(1, 1);
    waterMaterial.colorBlendFactor = 0;

    // Water mesh
   /* var waterMesh = BABYLON.Mesh.CreateGround("waterMesh", camera.radius, camera.radius, 16, scene, false);
    waterMesh.material = waterMaterial;

    waterMaterial.addToRenderList(skybox);
    waterMaterial.addToRenderList(ground);

*/

    // --------------- annyang Functions --------------------------


    var addTree = function () {
        // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
        var box = BABYLON.Mesh.CreateBox("box", 3, scene);

        box.position.y = 15 - Math.floor((Math.random() * 30) + 1);
        box.position.x = 15 - Math.floor((Math.random() * 30) + 1);
        box.position.z = Math.floor((Math.random() * 10) + 1);
        box.setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, {mass: 4});
        box.isPickable = true;


    };

    var addStone = function () {
        // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
        stoneIndex++;

        var stoneMesh = BABYLON.Mesh.CreateSphere("stone" + stoneIndex, 3, 50, scene);

        var stoneMaterial = new BABYLON.StandardMaterial("stoneMaterial" + stoneIndex, scene);
        stoneMaterial.diffuseTexture = new BABYLON.Texture("texturen/fels.jpg", scene);
        stoneMaterial.diffuseTexture.uScale = 2;
        stoneMaterial.diffuseTexture.vScale = 2;
        stoneMesh.material = stoneMaterial;

        stoneMesh.isPickable = true;
        stones.push(stoneMesh);
        stoneMove = true;

    };

    var randomPosBoxes = function () {
        // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
        for (var x = 0; x < boxes.length; x++) {
            boxes[x].position.z = Math.floor((Math.random() * 10) + 1);
        }
    };

    var physics = function () {
        scene.enablePhysics(new BABYLON.Vector3(0, -10, 0), new BABYLON.OimoJSPlugin());
    };


    // Resize
    window.addEventListener("resize", function () {
        engine.resize();

    });

    // -------- ANNYANG ------------
    if (annyang) {

        annyang.setLanguage("de-DE");
        // Let's define a command.
        var commands = {

            'Stein': addStone,
            'Baum': addTree,
            'Physik': physics
        };
        annyang.debug(true);
        // Add our commands to annyang
        annyang.addCommands(commands);


        // Start listening.
        annyang.start(true, true);
    }

    // ------------------------------

    var predicate = function (mesh) {

        return mesh.isPickable && mesh.isEnabled()

    }

    // Show some Debug Axis
    var showAxis = function (size) {
        var makeTextPlane = function (text, color, size) {
            var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
            dynamicTexture.hasAlpha = true;
            dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color, "transparent", true);
            var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
            plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
            plane.material.backFaceCulling = false;
            plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
            plane.material.diffuseTexture = dynamicTexture;
            return plane;
        };

        var axisX = BABYLON.Mesh.CreateLines("axisX", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
            new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
        ], scene);
        axisX.color = new BABYLON.Color3(1, 0, 0);
        var xChar = makeTextPlane("X", "red", size / 10);
        xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);
        var axisY = BABYLON.Mesh.CreateLines("axisY", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),
            new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)
        ], scene);
        axisY.color = new BABYLON.Color3(0, 1, 0);
        var yChar = makeTextPlane("Y", "green", size / 10);
        yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
        var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),
            new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)
        ], scene);
        axisZ.color = new BABYLON.Color3(0, 0, 1);
        var zChar = makeTextPlane("Z", "blue", size / 10);
        zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
    };

    showAxis(200)

    // Show Debug Ray for Leap Position
    var debugRay = BABYLON.Mesh.CreateLines("debugRay", [
        camera.position,
        new BABYLON.Vector3(camera.position.x, 0, 0),

    ], scene);

    var time = 0;
    var end = 3000;
    var displayArea = canvas.getContext("2d");

    // Render Loop + Leap Loop
    engine.runRenderLoop(function () {
        var controller = Leap.loop(function (frame) {

            var radius = camera.radius;

            var previousFrame = controller.frame[1];

            var appWidth = radius * 2;
            var appHeight = canvas.height;

            if (frame.hands.length > 0) {

                previousFrame = frame;

                var hand = frame.hands[0];
                var position = hand.palmPosition;
                var velocity = hand.palmVelocity;
                var direction = hand.direction;

                // ---------- LEAP COORDINATE MAPPING IN CAMERA COORDINATE ----------------

                canvas.width = canvas.width; //clear
                var interactionBox = frame.interactionBox;

                var normalizedPosition = interactionBox.normalizePoint(position, true);

                var canvasX = radius * 2 * normalizedPosition[0];
                var canvasY = radius * 2 * (1 - normalizedPosition[1]);
                var canvasZ = radius * 2 * normalizedPosition[2]

                leapX = (radius) - canvasX;
                leapY = (radius) - canvasY;
                leapZ = (radius) - canvasZ;

                // ------- RAY COLLOSION -------------


                    debugRay.position.x = leapX;
                    debugRay.position.y = leapY;
                    //         leapBox.position.x = leapX;
                    //          leapBox.position.y = leapY;

                    var origin = camera.position;
                    var pos = new BABYLON.Vector3(leapX, leapY, 0);

                    var dir = pos.subtract(origin).normalize();

                    var ray = new BABYLON.Ray(camera.position, dir, 2500);

                    var mesh = scene.pickWithRay(ray);


                // Stone is created and gets the  Position + Size depending on the Position/PinchStrength of the Hand at creation
                if (stoneMove) {
                    var stoneMesh = scene.getMeshByID("stone" + stoneIndex);
                    if (mesh.pickedMesh != null) {
                        var collisionPoint = mesh.pickedPoint

                        stoneMesh.position = collisionPoint;

                    }
                    var scaling = (2.0 - hand.pinchStrength)*4;
                    stoneMesh.scaling = new BABYLON.Vector3(scaling, scaling, scaling);

                    var mergedMeshes = BABYLON.Mesh.MergeMeshes(stones);
                    stones = [];
                    stones.push(mergedMeshes);
                }
                stoneMove = false;

                if(stones.length > 0 && frame.hands[1] != null && frame.hands[1].pinchStrength < 0.3){
                    var handNormPosition = interactionBox.normalizePoint(frame.hands[1].palmPosition, true);

                    stones[0].position.y = handNormPosition[1] * 100 - handNormPosition[1] * 100/2;
                }
            }

        }).use('screenPosition', {scale: 1});

        scene.render();

    });

</script>
</body>
</html>