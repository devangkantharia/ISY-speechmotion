<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <!--Favicon-->
    <link rel="shortcut icon" href="images/favicon.ico"/>
    <title>Babylon meets Leap Motion</title>
    <!-- Babylon.js -->

    <script src="js/babylon.js"></script>
    <script src="js/Oimo.js"></script>
    <script src="js/leap.js"></script>
    <script src="js/leap-plugins-0.1.11.js"></script>
    <script src="js/hand.js"></script>
    <script src="js/babylon.waterMaterial.js"></script>
    <script src="js/annyang.min.js"></script>

    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #cursor {
            position: absolute;
            left: -1000px;
            top: -1000px;
            z-index: 1;
            width: 10px;
            height: 10px;
            background-color: #ffffff;
            border-radius: 6px;
            -moz-border-radius: 6px;
            -webkit-border-radius: 6px;
            border: 1px solid #ff0000;
        }
    </style>

</head>
<body>

<div id="cursor"></div>

<canvas id="renderCanvas"></canvas>
<script type="text/javascript">

    // Leap Coordinates
    var leapX = 0;
    var leapY = 0;
    var leapZ = 0;
    var ground = 0;
    // Objects that can be created
    var stoneMove = false;
    var stoneIndex = 0;
    var stoneMesh = 0;
    var stones = new Array();

    //states
    var state = 1;
    var sceneObjects = [];
    var tree = 0;

    // ------- TEST STUFF---

    // Scene Creation
    var canvas = document.getElementById("renderCanvas");

    var engine = new BABYLON.Engine(canvas, true);
    var scene = new BABYLON.Scene(engine);

    //Physics
    scene.enablePhysics(new BABYLON.Vector3(0, -200, 0), new BABYLON.OimoJSPlugin());

    var camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.4, canvas.width, BABYLON.Vector3.Zero(), scene);
    scene.activeCamera = camera;
    camera.attachControl(canvas, true);

    var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, -1), scene);
    light.intensity = 1.0;

    // Plane Size
    var width = camera.radius / 3;
    var height = camera.radius / 3;

    // Skybox
    var skybox = BABYLON.Mesh.CreateBox("skyBox", canvas.width * 4, scene);
    var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
    skyboxMaterial.backFaceCulling = false;
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("skybox/morning", scene);
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
    skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    skybox.material = skyboxMaterial;

    // Anleitung

    var makeTextPlane = function (text, color, size) {
        var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 70, scene, true);
        dynamicTexture.hasAlpha = true;
        dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color, "transparent", true);
        var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
        plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
        plane.material.backFaceCulling = false;
        plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
        plane.material.diffuseTexture = dynamicTexture;
        return plane;
    };

 /*   var berg1 = makeTextPlane("Berg1", "blue", 90);
    berg1.position = new BABYLON.Vector3(getRandomInt(-width/2, width/3), width / 2 - getRandomInt(-width/2, width/3), 440);

    var berg2 = makeTextPlane("Berg2", "blue", 90);
    berg2.position = new BABYLON.Vector3(getRandomInt(-width/2, width/3), width / 2- getRandomInt(-width/2, width/3), 440);*/
    // -------------------------------------------------------

    var spots = [];

    function getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
    }
    // Place Spots
    for (var i = 0; i < 4; i++) {

        var spot = BABYLON.Mesh.CreateBox("spot" + i, 10, scene);
        var spotM = new BABYLON.StandardMaterial("spotM", scene);
        spotM.diffuseColor = new BABYLON.Color3(0.0, 0.0, 1.0);
        spot.material = spotM;
        spot.position.x = getRandomInt(-width/2, width/2);
        spot.position.y = getRandomInt(-width, width);
        spot.position.z = getRandomInt(-width/2, width/2);

        sceneObjects.push(spot);
        spots.push(spot);
    }


    // ------------------------------------------------------
    // BEFORE RENDERING - Collision Detection

    var angle = 0.0;
    scene.registerBeforeRender(function () {

        for (var i = 0; i < sceneObjects.length; i++) {

            var obj = sceneObjects[i];
            // Casting a ray to get height
            var ray = new BABYLON.Ray(new BABYLON.Vector3(obj.position.x, ground.getBoundingInfo().boundingBox.maximumWorld.y + 1, obj.position.z),
                    new BABYLON.Vector3(0, -1, 0)); // Direction
            var worldInverse = new BABYLON.Matrix();

            ground.getWorldMatrix().invertToRef(worldInverse);

            ray = BABYLON.Ray.Transform(ray, worldInverse);

            var pickInfo = ground.intersects(ray);

            if (pickInfo.hit) {
                obj.position.y = pickInfo.pickedPoint.y + 10;
            }

        }
        if (state == 3) {
            for (var i = 0; i < spots.length; i++) {

                if (tree.intersectsMesh(spots[i], false)) {
                    state = 1;
                    spots[i].material.diffuseColor = new BABYLON.Color3(0.0, 1.0, 0.0);
                }

            }
        }
    });

    // -------------------------------------------------------
    // Debug Box

    // Water material
    var waterMaterial = new BABYLON.WaterMaterial("waterMaterial", scene, new BABYLON.Vector2(32, 32));
    waterMaterial.bumpTexture = new BABYLON.Texture("Water/bump.png", scene);
    waterMaterial.windForce = -10;
    waterMaterial.waveHeight = 0.1;
    waterMaterial.bumpHeight = 1.1;
    waterMaterial.waveLength = 0.1;
    waterMaterial.waveSpeed = 5.0;
    waterMaterial.colorBlendFactor = 0;
    waterMaterial.windDirection = new BABYLON.Vector2(1, 1);
    waterMaterial.colorBlendFactor = 0;

    var bg = BABYLON.Mesh.CreatePlane("bg", width, scene);
    bg.position.y = width / 2;
    bg.position.z = 449;
    bg.material = new BABYLON.StandardMaterial("tex", scene);
    bg.material.diffuseTexture = new BABYLON.Texture("heightmaps/hm1.png", scene);
    bg.material.diffuseTexture.hasAlpha = true;


    // DYNAMIC TEXTURE
    var materialPlane = new BABYLON.StandardMaterial("texturePlane", scene);
    var texture = new BABYLON.DynamicTexture("dynamic texture", 300, scene, true);
    var textureContext = texture.getContext();

    materialPlane.specularColor = new BABYLON.Color3(1, 1, 1);
    materialPlane.diffuseTexture = texture;
    materialPlane.diffuseTexture.hasAlpha = true;
    materialPlane.emissiveColor = BABYLON.Color3.Black();
    materialPlane.backFaceCulling = false;//Always show the front and the back of an element

    var planeDT = BABYLON.Mesh.CreatePlane("plane", width, scene);
    planeDT.position.x = 0;
    planeDT.position.y = width / 2;
    planeDT.position.z = 450;
    planeDT.material = materialPlane;
    planeDT.material.diffuseTexture = texture;
    planeDT.isPickable = true;
    var imageurl = texture.getContext().canvas.toDataURL("image/png");

    // Ground Terrain
    ground = BABYLON.Mesh.CreateGroundFromHeightMap("ground", imageurl, width * 2, width * 2, 50, 0, 500, scene, true);
    var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
    groundMaterial.diffuseTexture = new BABYLON.Texture("texturen/sand.jpg", scene);
    groundMaterial.diffuseTexture.uScale = 6;
    groundMaterial.diffuseTexture.vScale = 6;
    groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    ground.material = groundMaterial;
    ground.isPickable = true;
    ground.position.y = -300;

    //And the brush canvas
    var brushcanvas = document.createElement('canvas');
    brushcanvas.width = width;
    brushcanvas.height = height;
    var brushcontext = brushcanvas.getContext('2d');

    brushcontext.fillStyle = 'rgba(' + 0 + ',' + 0 + ',' + 0 + ', 1.0)';
    brushcontext.fillRect(0, 0, width, width);
    textureContext.drawImage(brushcanvas, 0, 0);

    // -------- DRAW --------------------
    var textureSize = texture.getSize();
    texture.update();
    var oldAlpha = 0;

    var draw = function (pickResult, alpha) {
        var alphaSmooth = (oldAlpha + alpha) / 2;
        oldAlpha = alpha;

        var pickPoint = pickResult.pickedPoint;
        var x = pickPoint.x, y = pickPoint.y;

        x = width / 2 + x;
        y = width - y;

        brushcontext.save();
        brushcontext.globalAlpha = 0.3;
        brushcontext.beginPath();
        brushcontext.fillStyle = 'rgba(' + alphaSmooth + ',' + alphaSmooth + ',' + alphaSmooth + ', 0.2)';
        brushcontext.arc(x, y, 55, 0, 2 * Math.PI);
        brushcontext.fill();
        brushcontext.restore();

        textureContext.drawImage(brushcanvas, 0, 0);
        texture.update();
        imageurl = texture.getContext().canvas.toDataURL("image/png");

        planeDT.material.diffuseTexture = texture;

        ground.dispose();
        ground = BABYLON.Mesh.CreateGroundFromHeightMap("ground", imageurl, width * 2, width * 2, 50, 0, 150, scene, true);
        var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
        groundMaterial.diffuseTexture = new BABYLON.Texture("texturen/sand.jpg", scene);
        groundMaterial.diffuseTexture.uScale = 6;
        groundMaterial.diffuseTexture.vScale = 6;
        groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
        ground.material = groundMaterial;
        ground.material.backFaceCulling = true;
        ground.isPickable = true;
        ground.position.y = -300;


    };

    // --------------- Height Maps Gallery ------------------------


    var updateHeightmap = function (tex) {
        ground = BABYLON.Mesh.CreateGroundFromHeightMap("ground", tex.url, width, width, 100, 0, 150, scene, false);
    };


    // --------------- annyang Functions --------------------------


    var addTree = function () {

        camera.beta = -Math.PI / 2;

        state = 3;

        // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
        tree = BABYLON.Mesh.CreateBox("tree", 60, scene);
        var treeM = new BABYLON.StandardMaterial("treeM", scene);
        treeM.diffuseColor = new BABYLON.Color3(0.0, 1.0, 0.0);
        tree.material = treeM;

        sceneObjects.push(tree);
    };

    var addStone = function () {
        // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
        stoneIndex++;

        var stoneMesh = BABYLON.Mesh.CreateSphere("stone" + stoneIndex, 3, 50, scene);

        var stoneMaterial = new BABYLON.StandardMaterial("stoneMaterial" + stoneIndex, scene);
        stoneMaterial.diffuseTexture = new BABYLON.Texture("texturen/fels.jpg", scene);
        stoneMaterial.diffuseTexture.uScale = 2;
        stoneMaterial.diffuseTexture.vScale = 2;
        stoneMesh.material = stoneMaterial;

        stoneMesh.isPickable = true;
        stones.push(stoneMesh);
        stoneMove = true;

    };

    var randomPosBoxes = function () {
        // Our built-in 'ground' shape. Params: name, width, depth, subdivs, scene
        for (var x = 0; x < boxes.length; x++) {
            boxes[x].position.z = Math.floor((Math.random() * 10) + 1);
        }
    };

    var editMap = function () {

        camera.beta = Math.PI / 2.4;
        state = 2;
    };

    var addWater = function () {
        camera.beta = Math.PI / 2.4;

        state = 4;
        var waterMesh = BABYLON.Mesh.CreateGround("waterMesh", width * 2, width * 2, 20, scene, false);
        waterMesh.material = waterMaterial;
        waterMesh.position.y -= 290;

        waterMaterial.addToRenderList(skybox);
        waterMaterial.addToRenderList(ground);
    };


    // Resize
    window.addEventListener("resize", function () {
        engine.resize();

    });

    // -------- ANNYANG ------------
    if (annyang) {

        annyang.setLanguage("de-DE");
        // Let's define a command.
        var commands = {

            'Stein': addStone,
            'Baum': addTree,
            'Karte': editMap,
            'Wasser': addWater
        };
        annyang.debug(true);
        // Add our commands to annyang
        annyang.addCommands(commands);


        // Start listening.
        annyang.start(true, true);
    }

    // ------------------------------

    var predicate = function (mesh) {

        return mesh.isPickable && mesh.isEnabled()

    }

    // Show some Debug Axis
/*    var showAxis = function (size) {
     var axisX = BABYLON.Mesh.CreateLines("axisX", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
            new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
        ], scene);
        axisX.color = new BABYLON.Color3(1, 0, 0);
        var xChar = makeTextPlane("X", "red", size / 10);
        xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);
        var axisY = BABYLON.Mesh.CreateLines("axisY", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),
            new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)
        ], scene);
        axisY.color = new BABYLON.Color3(0, 1, 0);
        var yChar = makeTextPlane("Y", "green", size / 10);
        yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
        var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),
            new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)
        ], scene);
        axisZ.color = new BABYLON.Color3(0, 0, 1);
        var zChar = makeTextPlane("Z", "blue", size / 10);
        zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
    };

    showAxis(200)
*/
    // Show Debug Ray for Leap Position
  /*  var debugRay = BABYLON.Mesh.CreateLines("debugRay", [
        camera.position,
        new BABYLON.Vector3(0, 0, 0),

    ], scene);
*/
    var time = 0;
    var end = 3000;
    var displayArea = canvas.getContext("2d");
    var clickable = true;

    scene.updateTransformMatrix();
    //3D positions
    var _3Dposition = new BABYLON.Vector3(1, 1, 1);
    //Babylons Project Methog to convert 3D to 2D
    var _2Dposition = BABYLON.Vector3.Project(
            _3Dposition,
            BABYLON.Matrix.Identity(),   //world matrix
            scene.getTransformMatrix(), //transformation matrix
            scene.activeCamera.viewport.toGlobal(engine) //viewport
    );
    //set HTML position of "cursor"
    cursor.style.left = _2Dposition.x + 'px';
    cursor.style.top = _2Dposition.y + 'px';

    var controller = Leap.loop(function (frame) {


        var radius = camera.radius;

        var previousFrame = controller.frame[1];

        var appWidth = canvas.width;
        var appHeight = canvas.height;
        if (frame.hands.length > 0) {

            previousFrame = frame;

            var hand = frame.hands[0];
            var position = hand.palmPosition;
            var velocity = hand.palmVelocity;
            var direction = hand.direction;

            // ---------- LEAP COORDINATE MAPPING IN CAMERA COORDINATE ----------------

            canvas.width = canvas.width; //clear
            var interactionBox = frame.interactionBox;

            var normalizedPosition = interactionBox.normalizePoint(position, true);

            var canvasX = radius * 2 * (1 - normalizedPosition[0]);
            var canvasY = radius * 2 * (1 - normalizedPosition[1]);
            var canvasZ = radius * 2 * normalizedPosition[2]

            leapX = (radius) - canvasX;
            leapY = (radius) - canvasY;
            leapZ = (radius) - canvasZ;

            //cursors position is updated with leaps normalized position
            cursor.style.left = canvas.width / 2 + leapX + 'px';
            cursor.style.top = canvas.height / 2 - leapY + 60 + 'px';

       //     debugRay.position.x = leapX;
       //     debugRay.position.y = leapY;
            switch (state) {
                case 1:

                    break;

                case 2: // EDIT HIGH MAP

                    // ------- RAY COLLOSION -------------

                    var origin = camera.position;
                    var pos = new BABYLON.Vector3(leapX, leapY, 0);
                    var dir = pos.subtract(origin).normalize();
                    var ray = new BABYLON.Ray(camera.position, dir, 2500);
                    var mesh = scene.pickWithRay(ray);

                    if (mesh.pickedMesh != null) {

                        var collisionPoint = mesh.pickedPoint;

                        // Paint on Dynamic Texture
                        if (mesh.pickedMesh == planeDT || mesh.pickedMesh == bg) {
                            draw(mesh, hand.grabStrength * 200);
                        }
                    }

                    // Stone is created and gets the  Position + Size depending on the Position/PinchStrength of the Hand at creation
                    if (stoneMove) {
                        var stoneMesh = scene.getMeshByID("stone" + stoneIndex);
                        if (mesh.pickedMesh != null) {
                            var collisionPoint = mesh.pickedPoint

                            stoneMesh.position = collisionPoint;

                        }
                        var scaling = (2.0 - hand.pinchStrength) * 4;
                        stoneMesh.scaling = new BABYLON.Vector3(scaling, scaling, scaling);

                        var mergedMeshes = BABYLON.Mesh.MergeMeshes(stones);
                        stones = [];
                        stones.push(mergedMeshes);
                    }
                    stoneMove = false;

                    if (stones.length > 0 && frame.hands[1] != null && frame.hands[1].pinchStrength < 0.3) {
                        var handNormPosition = interactionBox.normalizePoint(frame.hands[1].palmPosition, true);

                        stones[0].position.y = handNormPosition[1] * 100 - handNormPosition[1] * 100 / 2;
                    }

                    break;

                case 3: // PLACE TREES

                    tree.position.x = leapX ;
                    tree.position.y = 0;
                    tree.position.z =  leapY ;

                    break;

                case 4: // Water

                    if (frame.gestures.length > 0) {
                        frame.gestures.forEach(function(gesture){
                            switch (gesture.type){
                                case "circle":

                                    var clockwise = false;
                                    var pointableID = gesture.pointableIds[0];
                                    var direction = frame.pointable(pointableID).direction;
                                    var dotProduct = Leap.vec3.dot(direction, gesture.normal);

                                    if (dotProduct  >  0) {
                                        clockwise = true;

                                        waterMaterial.waveHeight += 0.01;
                                        waterMaterial.waveSpeed += 2.0;

                                        if(waterMaterial.waveSpeed > 120){
                                            console.log("Sturm");
                                        }

                                    } else{
                                        clockwise = false;
                                        waterMaterial.waveHeight -=  0.01;
                                        waterMaterial.waveSpeed -= 2.0;

                                    }


                                    console.log("Circle Gesture");
                                    break;
                                case "keyTap":
                                    console.log("Key Tap Gesture");
                                    break;
                                case "screenTap":
                                    console.log("Screen Tap Gesture");
                                    break;
                                case "swipe":
                                    console.log("Swipe Gesture");
                                    break;
                            }
                        });
                    }

                    break;


            }

        }


    }).use('screenPosition', {scale: 1});

    // Render Loop + Leap Loop
    engine.runRenderLoop(function () {


        scene.render();

    });

</script>
</body>
</html>