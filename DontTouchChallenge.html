<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

    <title>Babylon.js sample code</title>
    <!-- Babylon.js -->
    <script src="js/hand.js"></script>
    <script src="js/oimo.js"></script>
    <script src="js/babylon.js"></script>
    <script src="js/leap.js"></script>
    <script src="js/leap-plugins-0.1.11.js"></script>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
<p>Framerate: <span id="leapFPS">FPS</span></p>
<p>Number of hands: <span id="handCount">Hands</span></p>
<p>Number of pointables: <span id="pointableCount">Pointables</span></p>
<p>Number of tools: <span id="toolCount">Tools</span></p>
<p>Number of fingers: <span id="fingerCount">Fingers</span></p>
<p>Number of gestures: <span id="gestureCount">Gestures</span></p>
<canvas id="renderCanvas"></canvas>
<script>

    // DEBUG
    var controller = new Leap.Controller({
        enableGestures: true,
        frameEventName: 'animationFrame'
    });

    var fpsDisplay = document.getElementById('leapFPS');
    var handCountDisplay = document.getElementById('handCount');
    var pointableCountDisplay = document.getElementById('pointableCount');
    var fingerCountDisplay = document.getElementById('fingerCount');
    var toolCountDisplay = document.getElementById('toolCount');
    var gestureCountDisplay = document.getElementById('gestureCount');

    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);
    var scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(.5, .5, .5);

    // FollowCamera >> Follow a mesh through your scene
    // Parameters : name, position, scene
    //  var camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 0, 0), scene);
    var camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 0, new BABYLON.Vector3(0, 0, 0), scene);
    camera.setPosition(new BABYLON.Vector3(0, 0, -70));
    camera.attachControl(canvas, true);

    // array of points
    var points = [];
    for (var i = 0; i < 50; i++) {
        points.push(new BABYLON.Vector3(i - 25, 5 * Math.sin(i / 4), 0));
    }
    var colliders = [];

    // Material
    var matPlan = new BABYLON.StandardMaterial("matPlan1", scene);
    matPlan.backFaceCulling = false;
    // matPlan.emissiveColor = new BABYLON.Color3(0.2, 1, 0.2);

    // Creation of a torus
    // (name, diameter, thickness, tessellation, scene, updatable)
    var torus = BABYLON.Mesh.CreateTorus("torus", 4, 0.5, 10, scene, false);
    torus.position = points[0];
    torus.material = matPlan;

    //intersection sphere
    var collideSphere1 = BABYLON.Mesh.CreateSphere("sphere1", 3, 1, scene);
    collideSphere1.position = points[0];

    var state = 1;

    scene.activeCamera = camera;

    var initial = new BABYLON.Vector3(0, 1, 0);

    // 3D Path Lines
    for (var p = 0; p < points.length - 2; p++) {
        var line = BABYLON.Mesh.CreateLines('line' + p, [new BABYLON.Vector3(points[p].x, points[p].y, 0), new BABYLON.Vector3(points[p + 1].x, points[p + 1].y, 0)], scene);
        colliders.push(line);
    }


    // Show some Debug Axis
    var showAxis = function (size) {
        var makeTextPlane = function (text, color, size) {
            var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", 50, scene, true);
            dynamicTexture.hasAlpha = true;
            dynamicTexture.drawText(text, 5, 40, "bold 36px Arial", color, "transparent", true);
            var plane = new BABYLON.Mesh.CreatePlane("TextPlane", size, scene, true);
            plane.material = new BABYLON.StandardMaterial("TextPlaneMaterial", scene);
            plane.material.backFaceCulling = false;
            plane.material.specularColor = new BABYLON.Color3(0, 0, 0);
            plane.material.diffuseTexture = dynamicTexture;
            return plane;
        };

        var axisX = BABYLON.Mesh.CreateLines("axisX", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),
            new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)
        ], scene);
        axisX.color = new BABYLON.Color3(1, 0, 0);


        var xChar = makeTextPlane("X", "red", size / 10);
        xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);
        var axisY = BABYLON.Mesh.CreateLines("axisY", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),
            new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)
        ], scene);
        axisY.color = new BABYLON.Color3(0, 1, 0);
        var yChar = makeTextPlane("Y", "green", size / 10);
        yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);
        var axisZ = BABYLON.Mesh.CreateLines("axisZ", [
            new BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),
            new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)
        ], scene);
        axisZ.color = new BABYLON.Color3(0, 0, 1);
        var zChar = makeTextPlane("Z", "blue", size / 10);
        zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);
    };

    showAxis(20);
    state = 2;
    var appWidth = 100;
    var appHeight = 50;

    // LEAP MOTION LOOP
    var controller = Leap.loop({enableGestures:true}, function (frame) {

        fpsDisplay.innerText = frame.currentFrameRate;
        handCountDisplay.innerText = frame.hands.length;
        pointableCountDisplay.innerText = frame.pointables.length;
        fingerCountDisplay.innerText = frame.fingers.length;
        toolCountDisplay.innerText = frame.tools.length;
        gestureCountDisplay.innerText = frame.gestures.length;

                if (frame.hands.length > 0) {

                    var rightHand = 0;
                    var leftHand = 0;

                    if (frame.hands[0].type == "right") {
                        rightHand = frame.hands[0];

                        var move = rightHand.palmVelocity;
                        var rollRadians = rightHand.roll();


                        switch (state) {
                                // Use Veloctiy for Moving
                            case 1:

                                torus.rotation.z = rollRadians;

                                if (move[0] > 0) {
                                    torus.position.x += move[0] / 1000;
                                    torus.position.y += move[1] / 1000;

                                    collideSphere1.position.x += move[0] / 1000;
                                    collideSphere1.position.y += move[1] / 1000;
                                }

                                break;
                            case 2: // Fixed Mapping for movement

                                var iBox = frame.interactionBox;
                                var pointable = frame.pointables[0];

                                var leapPoint = rightHand.stabilizedPalmPosition;
                                var normalized = iBox.normalizePoint(leapPoint, false);

                                torus.rotation.z = rollRadians;

                                var z = normalized[2];
                                // if changing from right-hand to left-hand rule, use:
                                //var z = normalized[2] * -1.0;
                                //recenter origin
                                var x = normalized[0] - 0.5;
                                z -= 0.5;
                                //scale
                                x *= 100;
                                var y = normalized[1] * 100;
                                z *= 100;

                                torus.position.x = x;
                                torus.position.y = y;

                                collideSphere1.position.x = x;
                                collideSphere1.position.y = y;
                                break;

                        }
                        // Collsion check

                        for (var p = 0; p < points.length - 2; p++) {
                            if (collideSphere1.intersectsMesh(colliders[p], true)) {
                                console.log("WAAA");
                                torus.material.emissiveColor = new BABYLON.Color3(1, 0, 1);
                            } else {
                                torus.material.emissiveColor = new BABYLON.Color3(0, 1, 0);
                            }
                        }
                    }
                }
            }
    ).use('screenPosition', {scale: 1});

    // RENDER LOOP
    engine.runRenderLoop(function () {
        scene.render();
    });

    // Resize
    window.addEventListener("resize", function () {
        engine.resize();
    });
</script>
</body>
</html>
